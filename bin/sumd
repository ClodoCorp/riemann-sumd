#!/usr/bin/env python

# Add cwd-relative lib to path
import sys
sys.path.append("lib")

# Just for sleep!
import time

# Import logging
import logging

# Import queueing library
import Queue

# Import threading library to manage threads
import threading

# Import option parser
from optparse import OptionParser

# YAML parser
# http://pyyaml.org/wiki/PyYAML
import yaml

# Daemonizing library - implements unix daemon functionality nicely
# http://pypi.python.org/pypi/python-daemon/
import daemon

# Riemann client library, depends on protobufs
# https://github.com/banjiewen/bernhard
import bernhard

# Task configuration loader library
import loader

# Task creation library
import task

# Scheduling library
import scheduler

# Task sending library
import sender

# Parse command line arguments
parser = OptionParser()
parser.add_option("--riemann-host", dest="riemann_host", default="localhost", help="Host that Riemann is running on")
parser.add_option("--riemann-port", dest="riemann_port", default=5555, help="Port that Riemann is running on")
parser.add_option("--task-limit", dest="task_limit", default=25, help="Limit of concurrent tasks running")
parser.add_option("--worker-limit", dest="worker_limit", default=5, help="Limit of concurrent event sending worker threads running")
parser.add_option("--dev-mode", dest="dev_mode", action='store_true', default=False, help="Enable development mode")
(options, args) = parser.parse_args()

# Configure logging
console = logging.StreamHandler()
console.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
log = logging.getLogger()
log.setLevel(logging.INFO)
log.addHandler(console)

# Load and schedule tasks
schedule = scheduler.TaskSchedule()
task_configs = loader.TaskLoader("examples/etc/sumd/tasks.d", "*.task")
task_configs.schedule_tasks(schedule)

# Load and add tags
tag_configs = loader.TagLoader("examples/etc/sumd/tags.d", "*.tag")
tag_configs.add_tags()

# Create task queue for worker threads, enable thread processing
tasks = Queue.Queue(options.task_limit)
enable_threads = threading.Event()
enable_threads.set()

# Create riemann client
riemann = bernhard.Client(host=options.riemann_host, port=options.riemann_port)

workers = []
for i in range(options.worker_limit):
	worker = sender.EventSender(tasks, riemann, enable_threads)
	worker.start()
	workers.append(worker)

while True:
	try:
		while schedule.waiting() > 0:
			task, deadline = schedule.next()
			task.start()
			tasks.put(task, block=True)
			schedule.add(task)
		else:
			time.sleep(1)
	except KeyboardInterrupt, SystemExit:
		for i in range(len(workers)):
			tasks.put("exit")
		enable_threads.clear()
		break
